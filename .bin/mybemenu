#!/usr/bin/env python3

import glob
import os
import subprocess
import sys


def run_command(cmd, check=True, capture_output=True):
    try:
        result = subprocess.run(cmd, shell=True, check=check, capture_output=capture_output, text=True)
        return result
    except subprocess.CalledProcessError as e:
        if check:
            print(f"Error running command '{cmd}': {e}")
        return None

def get_path_executables():
    """Get all executables from PATH"""
    executables = set()
    path_dirs = os.environ.get('PATH', '').split(':')
    
    for path_dir in path_dirs:
        if os.path.isdir(path_dir):
            try:
                for entry in os.listdir(path_dir):
                    full_path = os.path.join(path_dir, entry)
                    if os.path.isfile(full_path) and os.access(full_path, os.X_OK):
                        executables.add(entry)
            except (PermissionError, OSError):
                continue
    
    return sorted(executables)

def get_applications():
    """Get list of available applications (desktop files + PATH executables)"""
    applications = []
    seen_names = set()
    
    # First, get .desktop files
    app_dirs = [
        "/usr/share/applications",
        "/usr/local/share/applications", 
        f"{os.path.expanduser('~')}/.local/share/applications"
    ]
    
    for app_dir in app_dirs:
        if os.path.exists(app_dir):
            for desktop_file in glob.glob(f"{app_dir}/*.desktop"):
                try:
                    with open(desktop_file, 'r', encoding='utf-8') as f:
                        content = f.read()
                        
                    name = None
                    exec_cmd = None
                    no_display = False
                    
                    for line in content.split('\n'):
                        if line.startswith('Name='):
                            name = line.split('=', 1)[1].strip()
                        elif line.startswith('Exec='):
                            exec_cmd = line.split('=', 1)[1].strip()
                        elif line.startswith('NoDisplay='):
                            no_display = line.split('=', 1)[1].strip().lower() == 'true'
                    
                    if no_display or not name or not exec_cmd:
                        continue
                    
                    exec_cmd = exec_cmd.split('%')[0].strip()
                    applications.append((name, exec_cmd))
                    seen_names.add(name.lower())
                    
                except Exception:
                    continue
    
    # Then, add all PATH executables that aren't already in desktop files
    for exe in get_path_executables():
        if exe.lower() not in seen_names:
            applications.append((exe, exe))
    
    return sorted(applications, key=lambda x: x[0].lower())

def mybemenu(options, prompt="Select:", lines=None, case_insensitive=True):
    if isinstance(options, list):
        options_text = '\n'.join(options)
    else:
        options_text = options
    
    cmd_parts = [
        "bemenu",
        "-i" if case_insensitive else "",
        f"-l {lines}" if lines else "",
        "--fb '#222222'",
        "--ff '#bbbbbb'", 
        "--nb '#222222'",
        "--nf '#bbbbbb'",
        "--tb '#005577'",
        "--hb '#005577'",
        "--tf '#eeeeee'",
        "--hf '#eeeeee'",
        "--af '#bbbbbb'",
        "--ab '#222222'",
        "--fn 'JetBrainsMono 9'",
        "-H 25",
        f"-p '{prompt}'"
    ]
    
    cmd = ' '.join(filter(None, cmd_parts))
    
    result = run_command(f"printf '{options_text}' | {cmd}", check=False)
    if result and result.returncode == 0:
        return result.stdout.strip()
    return None

def main():
    if len(sys.argv) < 2:
        print("Usage: mybemenu <options> [prompt] [lines]")
        print("       mybemenu --apps")
        print("  options: space-separated list or '-' for stdin")
        print("  prompt: menu prompt (default: 'Select:')")
        print("  lines: number of lines to show (default: auto)")
        print("  --apps: show application launcher")
        sys.exit(1)
    
    if sys.argv[1] == "--apps":
        applications = get_applications()
        if not applications:
            print("No applications found")
            return
        
        options = [name for name, _ in applications]
        result = mybemenu(options, "Applications:", 10)
        
        if result:
            for name, exec_cmd in applications:
                if name == result:
                    subprocess.Popen(exec_cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    break
        return
    
    options = sys.argv[1]
    prompt = sys.argv[2] if len(sys.argv) > 2 else "Select:"
    lines = int(sys.argv[3]) if len(sys.argv) > 3 else None
    
    if options == "-":
        options_text = sys.stdin.read().strip()
    else:
        options_text = options
    
    options_list = [opt.strip() for opt in options_text.split() if opt.strip()]
    
    result = mybemenu(options_list, prompt, lines)
    if result:
        print(result)
    else:
        sys.exit(1)

if __name__ == "__main__":
    main()
